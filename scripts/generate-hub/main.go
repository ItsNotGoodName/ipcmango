// Package main generates bus based on all structs in a file.
package main

import (
	"os"
	"path"
	"regexp"
	"text/template"
)

type TemplateData struct {
	By      string
	Package string
	Imports []string
	Events  []string
}

const rawTemplate = `// Code generated by {{ .By }}; DO NOT EDIT.
package {{ .Package }}

import (
{{ range .Imports }}
	"{{.}}"
{{ end }}
)

func hubLogError(name string, err error) {
	if err != nil {
		log.Err(err).Str("package", "{{ .Package }}").Str("name", name).Send()
	}
}

func NewHub(ctx context.Context) *Hub {
	return &Hub{
		ctx: ctx,
	}
}

type Hub struct {
	ctx context.Context
{{ range .Events }}
	on{{.}} []func(ctx context.Context, event {{ . }}) error
	names{{.}} []string
{{ end }}
}

func (b *Hub) Register(pub *pubsub.Pub) (*Hub) {
{{ range .Events }}
	b.On{{ . }}("pubsub", func(ctx context.Context, event {{ . }}) error {
		err := pub.Broadcast(ctx, event)
		if err == nil {
			return nil
		}
		return err
	})
{{ end }}
	return b
}

{{ range .Events }}
func (h *Hub) On{{ . }}(name string, fn func(ctx context.Context, event {{ . }}) error) {
	h.on{{ . }} = append(h.on{{ . }}, fn)
	h.names{{ . }} = append(h.names{{ . }}, name)
}
{{ end }}

{{ range .Events }}
func (h *Hub) {{ . }}(event {{ . }}) {
	for i, v := range h.on{{ . }} {
		hubLogError(h.names{{ . }}[i], v(h.ctx, event))
	}
}
{{ end }}
`

type Args struct {
	InputFilePath string
}

func ParseArgs() Args {
	return Args{
		InputFilePath: path.Clean(os.Args[1]),
	}
}

func main() {
	args := ParseArgs()
	outputFilePath := path.Join(path.Dir(args.InputFilePath), "hub.gen.go")

	_ = os.Remove(outputFilePath)

	must(must2(template.
		New("").
		Parse(rawTemplate)).
		Execute(must2(os.OpenFile(outputFilePath, os.O_CREATE|os.O_WRONLY, 0644)), TemplateData{
			By:      "generate-bus.go",
			Package: "bus",
			Imports: []string{
				"context",
				"github.com/ItsNotGoodName/ipcmanview/pkg/pubsub",
				"github.com/rs/zerolog/log",
			},
			Events: events(args.InputFilePath),
		}))
}

func events(filePath string) []string {
	var events []string
	for _, v := range must2(regexp.Compile(`type (.*?) struct {`)).FindAllStringSubmatch(string(must2(os.ReadFile(filePath))), -1) {
		events = append(events, v[1])
	}
	return events
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}

func must2[T any](d T, err error) T {
	if err != nil {
		panic(err)
	}
	return d
}
