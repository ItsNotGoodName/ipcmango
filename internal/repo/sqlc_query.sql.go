// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: sqlc_query.sql

package repo

import (
	"context"
	"database/sql"
	"encoding/json"
	"strings"

	"github.com/ItsNotGoodName/ipcmanview/internal/models"
	"github.com/ItsNotGoodName/ipcmanview/internal/types"
)

const checkDahuaDevice = `-- name: CheckDahuaDevice :one
SELECT
  COUNT(*) = 1
FROM
  dahua_devices
WHERE
  id = ?
`

func (q *Queries) CheckDahuaDevice(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkDahuaDevice, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const countGroup = `-- name: CountGroup :one
SELECT
  count(*)
FROM
  groups
`

func (q *Queries) CountGroup(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countGroup)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDahuaAferoFile = `-- name: CreateDahuaAferoFile :one
INSERT INTO
  dahua_afero_files (
    file_id,
    thumbnail_id,
    email_attachment_id,
    name,
    created_at
  )
VALUES
  (?, ?, ?, ?, ?) RETURNING id
`

type CreateDahuaAferoFileParams struct {
	FileID            sql.NullInt64
	ThumbnailID       sql.NullInt64
	EmailAttachmentID sql.NullInt64
	Name              string
	CreatedAt         types.Time
}

func (q *Queries) CreateDahuaAferoFile(ctx context.Context, arg CreateDahuaAferoFileParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDahuaAferoFile,
		arg.FileID,
		arg.ThumbnailID,
		arg.EmailAttachmentID,
		arg.Name,
		arg.CreatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDahuaEvent = `-- name: CreateDahuaEvent :one
INSERT INTO
  dahua_events (
    device_id,
    code,
    action,
    ` + "`" + `index` + "`" + `,
    data,
    created_at
  )
VALUES
  (?, ?, ?, ?, ?, ?) RETURNING id
`

type CreateDahuaEventParams struct {
	DeviceID  int64
	Code      string
	Action    string
	Index     int64
	Data      json.RawMessage
	CreatedAt types.Time
}

func (q *Queries) CreateDahuaEvent(ctx context.Context, arg CreateDahuaEventParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDahuaEvent,
		arg.DeviceID,
		arg.Code,
		arg.Action,
		arg.Index,
		arg.Data,
		arg.CreatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDahuaEventRule = `-- name: CreateDahuaEventRule :exec
INSERT INTO
  dahua_event_rules (code, ignore_db, ignore_live, ignore_mqtt)
VALUES
  (?, ?, ?, ?)
`

type CreateDahuaEventRuleParams struct {
	Code       string
	IgnoreDb   bool
	IgnoreLive bool
	IgnoreMqtt bool
}

func (q *Queries) CreateDahuaEventRule(ctx context.Context, arg CreateDahuaEventRuleParams) error {
	_, err := q.db.ExecContext(ctx, createDahuaEventRule,
		arg.Code,
		arg.IgnoreDb,
		arg.IgnoreLive,
		arg.IgnoreMqtt,
	)
	return err
}

const createDahuaEventWorkerState = `-- name: CreateDahuaEventWorkerState :exec
INSERT INTO
  dahua_event_worker_states (device_id, state, error, created_at)
VALUES
  (?, ?, ?, ?)
`

type CreateDahuaEventWorkerStateParams struct {
	DeviceID  int64
	State     models.DahuaEventWorkerState
	Error     sql.NullString
	CreatedAt types.Time
}

func (q *Queries) CreateDahuaEventWorkerState(ctx context.Context, arg CreateDahuaEventWorkerStateParams) error {
	_, err := q.db.ExecContext(ctx, createDahuaEventWorkerState,
		arg.DeviceID,
		arg.State,
		arg.Error,
		arg.CreatedAt,
	)
	return err
}

const createDahuaFile = `-- name: CreateDahuaFile :one
INSERT INTO
  dahua_files (
    device_id,
    channel,
    start_time,
    end_time,
    length,
    type,
    file_path,
    duration,
    disk,
    video_stream,
    flags,
    events,
    cluster,
    partition,
    pic_index,
    repeat,
    work_dir,
    work_dir_sn,
    updated_at,
    storage
  )
VALUES
  (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
  )
ON CONFLICT (start_time) DO
UPDATE
SET
  id = id RETURNING id
`

type CreateDahuaFileParams struct {
	DeviceID    int64
	Channel     int64
	StartTime   types.Time
	EndTime     types.Time
	Length      int64
	Type        string
	FilePath    string
	Duration    int64
	Disk        int64
	VideoStream string
	Flags       types.StringSlice
	Events      types.StringSlice
	Cluster     int64
	Partition   int64
	PicIndex    int64
	Repeat      int64
	WorkDir     string
	WorkDirSn   bool
	UpdatedAt   types.Time
	Storage     models.Storage
}

func (q *Queries) CreateDahuaFile(ctx context.Context, arg CreateDahuaFileParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDahuaFile,
		arg.DeviceID,
		arg.Channel,
		arg.StartTime,
		arg.EndTime,
		arg.Length,
		arg.Type,
		arg.FilePath,
		arg.Duration,
		arg.Disk,
		arg.VideoStream,
		arg.Flags,
		arg.Events,
		arg.Cluster,
		arg.Partition,
		arg.PicIndex,
		arg.Repeat,
		arg.WorkDir,
		arg.WorkDirSn,
		arg.UpdatedAt,
		arg.Storage,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDahuaStorageDestination = `-- name: CreateDahuaStorageDestination :one
INSERT INTO
  dahua_storage_destinations (
    name,
    storage,
    server_address,
    port,
    username,
    password,
    remote_directory
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?) RETURNING id
`

type CreateDahuaStorageDestinationParams struct {
	Name            string
	Storage         models.Storage
	ServerAddress   string
	Port            int64
	Username        string
	Password        string
	RemoteDirectory string
}

func (q *Queries) CreateDahuaStorageDestination(ctx context.Context, arg CreateDahuaStorageDestinationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDahuaStorageDestination,
		arg.Name,
		arg.Storage,
		arg.ServerAddress,
		arg.Port,
		arg.Username,
		arg.Password,
		arg.RemoteDirectory,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDahuaThumbnail = `-- name: CreateDahuaThumbnail :one
INSERT INTO
  dahua_thumbnails (file_id, email_attachment_id, width, height)
VALUES
  (?, ?, ?, ?) RETURNING id, file_id, email_attachment_id, width, height
`

type CreateDahuaThumbnailParams struct {
	FileID            sql.NullInt64
	EmailAttachmentID sql.NullInt64
	Width             int64
	Height            int64
}

func (q *Queries) CreateDahuaThumbnail(ctx context.Context, arg CreateDahuaThumbnailParams) (DahuaThumbnail, error) {
	row := q.db.QueryRowContext(ctx, createDahuaThumbnail,
		arg.FileID,
		arg.EmailAttachmentID,
		arg.Width,
		arg.Height,
	)
	var i DahuaThumbnail
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.EmailAttachmentID,
		&i.Width,
		&i.Height,
	)
	return i, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO
  groups (name, description, created_at, updated_at)
VALUES
  (?, ?, ?, ?) RETURNING id
`

type CreateGroupParams struct {
	Name        string
	Description string
	CreatedAt   types.Time
	UpdatedAt   types.Time
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createGroup,
		arg.Name,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
  users (email, username, password, created_at, updated_at)
VALUES
  (?, ?, ?, ?, ?) RETURNING id
`

type CreateUserParams struct {
	Email     string
	Username  string
	Password  string
	CreatedAt types.Time
	UpdatedAt types.Time
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUserSession = `-- name: CreateUserSession :exec
INSERT INTO
  user_sessions (
    user_id,
    session,
    user_agent,
    ip,
    last_ip,
    last_used_at,
    created_at,
    expired_at
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateUserSessionParams struct {
	UserID     int64
	Session    string
	UserAgent  string
	Ip         string
	LastIp     string
	LastUsedAt types.Time
	CreatedAt  types.Time
	ExpiredAt  types.Time
}

func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) error {
	_, err := q.db.ExecContext(ctx, createUserSession,
		arg.UserID,
		arg.Session,
		arg.UserAgent,
		arg.Ip,
		arg.LastIp,
		arg.LastUsedAt,
		arg.CreatedAt,
		arg.ExpiredAt,
	)
	return err
}

const deleteDahuaAferoFile = `-- name: DeleteDahuaAferoFile :exec
DELETE FROM dahua_afero_files
WHERE
  id = ?
`

func (q *Queries) DeleteDahuaAferoFile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaAferoFile, id)
	return err
}

const deleteDahuaDevice = `-- name: DeleteDahuaDevice :exec
DELETE FROM dahua_devices
WHERE
  id = ?
`

func (q *Queries) DeleteDahuaDevice(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaDevice, id)
	return err
}

const deleteDahuaEvent = `-- name: DeleteDahuaEvent :exec
DELETE FROM dahua_events
`

func (q *Queries) DeleteDahuaEvent(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaEvent)
	return err
}

const deleteDahuaEventRule = `-- name: DeleteDahuaEventRule :exec
DELETE FROM dahua_event_rules
WHERE
  id = ?
`

func (q *Queries) DeleteDahuaEventRule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaEventRule, id)
	return err
}

const deleteDahuaFile = `-- name: DeleteDahuaFile :exec
DELETE FROM dahua_files
WHERE
  updated_at < ?1
  AND device_id = ?2
  AND start_time <= ?3
  AND ?4 < start_time
`

type DeleteDahuaFileParams struct {
	UpdatedAt types.Time
	DeviceID  int64
	End       types.Time
	Start     types.Time
}

func (q *Queries) DeleteDahuaFile(ctx context.Context, arg DeleteDahuaFileParams) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaFile,
		arg.UpdatedAt,
		arg.DeviceID,
		arg.End,
		arg.Start,
	)
	return err
}

const deleteDahuaStorageDestination = `-- name: DeleteDahuaStorageDestination :exec
DELETE FROM dahua_storage_destinations
WHERE
  id = ?
`

func (q *Queries) DeleteDahuaStorageDestination(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaStorageDestination, id)
	return err
}

const deleteDahuaStream = `-- name: DeleteDahuaStream :exec
DELETE FROM dahua_streams
WHERE
  id = ?
`

func (q *Queries) DeleteDahuaStream(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDahuaStream, id)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM groups
WHERE
  id = ?
`

func (q *Queries) DeleteGroup(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, id)
	return err
}

const deleteUserSessionByExpired = `-- name: DeleteUserSessionByExpired :exec
DELETE FROM user_sessions
WHERE
  expired_at < ?
`

func (q *Queries) DeleteUserSessionByExpired(ctx context.Context, expiredAt types.Time) error {
	_, err := q.db.ExecContext(ctx, deleteUserSessionByExpired, expiredAt)
	return err
}

const deleteUserSessionBySession = `-- name: DeleteUserSessionBySession :exec
DELETE FROM user_sessions
WHERE
  session = ?
`

func (q *Queries) DeleteUserSessionBySession(ctx context.Context, session string) error {
	_, err := q.db.ExecContext(ctx, deleteUserSessionBySession, session)
	return err
}

const deleteUserSessionForUser = `-- name: DeleteUserSessionForUser :exec
DELETE FROM user_sessions
WHERE
  id = ?
  AND user_id = ?
`

type DeleteUserSessionForUserParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeleteUserSessionForUser(ctx context.Context, arg DeleteUserSessionForUserParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserSessionForUser, arg.ID, arg.UserID)
	return err
}

const deleteUserSessionForUserAndNotSession = `-- name: DeleteUserSessionForUserAndNotSession :exec
DELETE FROM user_sessions
WHERE
  user_id = ?
  AND session != ?
`

type DeleteUserSessionForUserAndNotSessionParams struct {
	UserID  int64
	Session string
}

func (q *Queries) DeleteUserSessionForUserAndNotSession(ctx context.Context, arg DeleteUserSessionForUserAndNotSessionParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserSessionForUserAndNotSession, arg.UserID, arg.Session)
	return err
}

const getDahuaAferoFileByFileID = `-- name: GetDahuaAferoFileByFileID :one
SELECT
  id, file_id, thumbnail_id, email_attachment_id, name, ready, size, created_at
FROM
  dahua_afero_files
WHERE
  file_id = ?
`

func (q *Queries) GetDahuaAferoFileByFileID(ctx context.Context, fileID sql.NullInt64) (DahuaAferoFile, error) {
	row := q.db.QueryRowContext(ctx, getDahuaAferoFileByFileID, fileID)
	var i DahuaAferoFile
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.ThumbnailID,
		&i.EmailAttachmentID,
		&i.Name,
		&i.Ready,
		&i.Size,
		&i.CreatedAt,
	)
	return i, err
}

const getDahuaDevice = `-- name: GetDahuaDevice :one
SELECT
  dahua_devices.id, dahua_devices.name, dahua_devices.ip, dahua_devices.url, dahua_devices.username, dahua_devices.password, dahua_devices.location, dahua_devices.feature, dahua_devices.created_at, dahua_devices.updated_at, dahua_devices.disabled_at,
  coalesce(seed, id)
FROM
  dahua_devices
  LEFT JOIN dahua_seeds ON dahua_seeds.device_id = dahua_devices.id
WHERE
  id = ?
LIMIT
  1
`

type GetDahuaDeviceRow struct {
	ID         int64
	Name       string
	Ip         string
	Url        types.URL
	Username   string
	Password   string
	Location   types.Location
	Feature    models.DahuaFeature
	CreatedAt  types.Time
	UpdatedAt  types.Time
	DisabledAt types.NullTime
	Seed       int64
}

func (q *Queries) GetDahuaDevice(ctx context.Context, id int64) (GetDahuaDeviceRow, error) {
	row := q.db.QueryRowContext(ctx, getDahuaDevice, id)
	var i GetDahuaDeviceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Ip,
		&i.Url,
		&i.Username,
		&i.Password,
		&i.Location,
		&i.Feature,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DisabledAt,
		&i.Seed,
	)
	return i, err
}

const getDahuaDeviceByIP = `-- name: GetDahuaDeviceByIP :one
SELECT
  dahua_devices.id, dahua_devices.name, dahua_devices.ip, dahua_devices.url, dahua_devices.username, dahua_devices.password, dahua_devices.location, dahua_devices.feature, dahua_devices.created_at, dahua_devices.updated_at, dahua_devices.disabled_at,
  coalesce(seed, id)
FROM
  dahua_devices
  LEFT JOIN dahua_seeds ON dahua_seeds.device_id = dahua_devices.id
WHERE
  ip = ?
LIMIT
  1
`

type GetDahuaDeviceByIPRow struct {
	ID         int64
	Name       string
	Ip         string
	Url        types.URL
	Username   string
	Password   string
	Location   types.Location
	Feature    models.DahuaFeature
	CreatedAt  types.Time
	UpdatedAt  types.Time
	DisabledAt types.NullTime
	Seed       int64
}

func (q *Queries) GetDahuaDeviceByIP(ctx context.Context, ip string) (GetDahuaDeviceByIPRow, error) {
	row := q.db.QueryRowContext(ctx, getDahuaDeviceByIP, ip)
	var i GetDahuaDeviceByIPRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Ip,
		&i.Url,
		&i.Username,
		&i.Password,
		&i.Location,
		&i.Feature,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DisabledAt,
		&i.Seed,
	)
	return i, err
}

const getDahuaDeviceName = `-- name: GetDahuaDeviceName :one
SELECT
  name
FROM
  dahua_devices
WHERE
  id = ?
`

func (q *Queries) GetDahuaDeviceName(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getDahuaDeviceName, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getDahuaEventData = `-- name: GetDahuaEventData :one
SELECT
  data
FROM
  dahua_events
WHERE
  id = ?
`

func (q *Queries) GetDahuaEventData(ctx context.Context, id int64) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getDahuaEventData, id)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const getDahuaEventRule = `-- name: GetDahuaEventRule :one
SELECT
  id, code, ignore_db, ignore_live, ignore_mqtt
FROM
  dahua_event_rules
WHERE
  id = ?
`

func (q *Queries) GetDahuaEventRule(ctx context.Context, id int64) (DahuaEventRule, error) {
	row := q.db.QueryRowContext(ctx, getDahuaEventRule, id)
	var i DahuaEventRule
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.IgnoreDb,
		&i.IgnoreLive,
		&i.IgnoreMqtt,
	)
	return i, err
}

const getDahuaFile = `-- name: GetDahuaFile :one
SELECT
  id, device_id, channel, start_time, end_time, length, type, file_path, duration, disk, video_stream, flags, events, cluster, "partition", pic_index, repeat, work_dir, work_dir_sn, updated_at, storage
FROM
  dahua_files
WHERE
  id = ?
`

func (q *Queries) GetDahuaFile(ctx context.Context, id int64) (DahuaFile, error) {
	row := q.db.QueryRowContext(ctx, getDahuaFile, id)
	var i DahuaFile
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Channel,
		&i.StartTime,
		&i.EndTime,
		&i.Length,
		&i.Type,
		&i.FilePath,
		&i.Duration,
		&i.Disk,
		&i.VideoStream,
		&i.Flags,
		&i.Events,
		&i.Cluster,
		&i.Partition,
		&i.PicIndex,
		&i.Repeat,
		&i.WorkDir,
		&i.WorkDirSn,
		&i.UpdatedAt,
		&i.Storage,
	)
	return i, err
}

const getDahuaFileByFilePath = `-- name: GetDahuaFileByFilePath :one
SELECT
  id, device_id, channel, start_time, end_time, length, type, file_path, duration, disk, video_stream, flags, events, cluster, "partition", pic_index, repeat, work_dir, work_dir_sn, updated_at, storage
FROM
  dahua_files
WHERE
  device_id = ?
  and file_path = ?
`

type GetDahuaFileByFilePathParams struct {
	DeviceID int64
	FilePath string
}

func (q *Queries) GetDahuaFileByFilePath(ctx context.Context, arg GetDahuaFileByFilePathParams) (DahuaFile, error) {
	row := q.db.QueryRowContext(ctx, getDahuaFileByFilePath, arg.DeviceID, arg.FilePath)
	var i DahuaFile
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Channel,
		&i.StartTime,
		&i.EndTime,
		&i.Length,
		&i.Type,
		&i.FilePath,
		&i.Duration,
		&i.Disk,
		&i.VideoStream,
		&i.Flags,
		&i.Events,
		&i.Cluster,
		&i.Partition,
		&i.PicIndex,
		&i.Repeat,
		&i.WorkDir,
		&i.WorkDirSn,
		&i.UpdatedAt,
		&i.Storage,
	)
	return i, err
}

const getDahuaFileForThumbnail = `-- name: GetDahuaFileForThumbnail :one
SELECT
  dahua_files.id,
  device_id,
  type,
  file_path,
  name,
  ready
FROM
  dahua_files
  LEFT JOIN dahua_thumbnails ON dahua_thumbnails.file_id = dahua_files.id
  LEFT JOIN dahua_afero_files ON dahua_afero_files.thumbnail_id = dahua_thumbnails.id
WHERE
  dahua_files.id = ?
`

type GetDahuaFileForThumbnailRow struct {
	ID       int64
	DeviceID int64
	Type     string
	FilePath string
	Name     sql.NullString
	Ready    sql.NullBool
}

func (q *Queries) GetDahuaFileForThumbnail(ctx context.Context, id int64) (GetDahuaFileForThumbnailRow, error) {
	row := q.db.QueryRowContext(ctx, getDahuaFileForThumbnail, id)
	var i GetDahuaFileForThumbnailRow
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Type,
		&i.FilePath,
		&i.Name,
		&i.Ready,
	)
	return i, err
}

const getDahuaStorageDestination = `-- name: GetDahuaStorageDestination :one
SELECT
  id, name, storage, server_address, port, username, password, remote_directory
FROM
  dahua_storage_destinations
WHERE
  id = ?
`

func (q *Queries) GetDahuaStorageDestination(ctx context.Context, id int64) (DahuaStorageDestination, error) {
	row := q.db.QueryRowContext(ctx, getDahuaStorageDestination, id)
	var i DahuaStorageDestination
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Storage,
		&i.ServerAddress,
		&i.Port,
		&i.Username,
		&i.Password,
		&i.RemoteDirectory,
	)
	return i, err
}

const getDahuaStorageDestinationByServerAddressAndStorage = `-- name: GetDahuaStorageDestinationByServerAddressAndStorage :one
SELECT
  id, name, storage, server_address, port, username, password, remote_directory
FROM
  dahua_storage_destinations
WHERE
  server_address = ?
  AND storage = ?
`

type GetDahuaStorageDestinationByServerAddressAndStorageParams struct {
	ServerAddress string
	Storage       models.Storage
}

func (q *Queries) GetDahuaStorageDestinationByServerAddressAndStorage(ctx context.Context, arg GetDahuaStorageDestinationByServerAddressAndStorageParams) (DahuaStorageDestination, error) {
	row := q.db.QueryRowContext(ctx, getDahuaStorageDestinationByServerAddressAndStorage, arg.ServerAddress, arg.Storage)
	var i DahuaStorageDestination
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Storage,
		&i.ServerAddress,
		&i.Port,
		&i.Username,
		&i.Password,
		&i.RemoteDirectory,
	)
	return i, err
}

const getDahuaStream = `-- name: GetDahuaStream :one
SELECT
  id, internal, device_id, channel, subtype, name, mediamtx_path
FROM
  dahua_streams
WHERE
  id = ?
`

func (q *Queries) GetDahuaStream(ctx context.Context, id int64) (DahuaStream, error) {
	row := q.db.QueryRowContext(ctx, getDahuaStream, id)
	var i DahuaStream
	err := row.Scan(
		&i.ID,
		&i.Internal,
		&i.DeviceID,
		&i.Channel,
		&i.Subtype,
		&i.Name,
		&i.MediamtxPath,
	)
	return i, err
}

const getGroup = `-- name: GetGroup :one
SELECT
  id, name, description, created_at, updated_at, disabled_at
FROM
  groups
where
  id = ?
`

func (q *Queries) GetGroup(ctx context.Context, id int64) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroup, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DisabledAt,
	)
	return i, err
}

const getOldestDahuaFileStartTime = `-- name: GetOldestDahuaFileStartTime :one
SELECT
  start_time
FROM
  dahua_files
WHERE
  device_id = ?
ORDER BY
  start_time ASC
LIMIT
  1
`

func (q *Queries) GetOldestDahuaFileStartTime(ctx context.Context, deviceID int64) (types.Time, error) {
	row := q.db.QueryRowContext(ctx, getOldestDahuaFileStartTime, deviceID)
	var start_time types.Time
	err := row.Scan(&start_time)
	return start_time, err
}

const getSettings = `-- name: GetSettings :one
SELECT
  setup, site_name, location, coordinates
FROM
  settings
LIMIT
  1
`

func (q *Queries) GetSettings(ctx context.Context) (Setting, error) {
	row := q.db.QueryRowContext(ctx, getSettings)
	var i Setting
	err := row.Scan(
		&i.Setup,
		&i.SiteName,
		&i.Location,
		&i.Coordinates,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT
  id, email, username, password, created_at, updated_at, disabled_at
FROM
  users
where
  id = ?
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DisabledAt,
	)
	return i, err
}

const getUserByGroup = `-- name: GetUserByGroup :many
SELECT
  users.id, users.email, users.username, users.password, users.created_at, users.updated_at, users.disabled_at
FROM
  users
  LEFT JOIN group_users ON group_users.user_id = id
WHERE
  group_users.group_id = ?
`

func (q *Queries) GetUserByGroup(ctx context.Context, groupID int64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUserByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisabledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBySession = `-- name: GetUserBySession :one
SELECT
  user_sessions.id as id,
  user_sessions.user_id as user_id,
  users.username,
  admins.user_id IS NOT NULL as 'admin',
  user_sessions.last_ip,
  user_sessions.last_used_at,
  user_sessions.expired_at
FROM
  user_sessions
  LEFT JOIN users ON users.id = user_sessions.user_id
  LEFT JOIN admins ON admins.user_id = user_sessions.user_id
WHERE
  session = ?
`

type GetUserBySessionRow struct {
	ID         int64
	UserID     int64
	Username   sql.NullString
	Admin      bool
	LastIp     string
	LastUsedAt types.Time
	ExpiredAt  types.Time
}

func (q *Queries) GetUserBySession(ctx context.Context, session string) (GetUserBySessionRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBySession, session)
	var i GetUserBySessionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Admin,
		&i.LastIp,
		&i.LastUsedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getUserByUsernameOrEmail = `-- name: GetUserByUsernameOrEmail :one
SELECT
  id, email, username, password, created_at, updated_at, disabled_at
FROM
  users
where
  username = ?1
  OR email = ?1
`

func (q *Queries) GetUserByUsernameOrEmail(ctx context.Context, usernameoremail string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsernameOrEmail, usernameoremail)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DisabledAt,
	)
	return i, err
}

const listDahuaDevices = `-- name: ListDahuaDevices :many
SELECT
  dahua_devices.id, dahua_devices.name, dahua_devices.ip, dahua_devices.url, dahua_devices.username, dahua_devices.password, dahua_devices.location, dahua_devices.feature, dahua_devices.created_at, dahua_devices.updated_at, dahua_devices.disabled_at,
  coalesce(seed, id)
FROM
  dahua_devices
  LEFT JOIN dahua_seeds ON dahua_seeds.device_id = dahua_devices.id
`

type ListDahuaDevicesRow struct {
	ID         int64
	Name       string
	Ip         string
	Url        types.URL
	Username   string
	Password   string
	Location   types.Location
	Feature    models.DahuaFeature
	CreatedAt  types.Time
	UpdatedAt  types.Time
	DisabledAt types.NullTime
	Seed       int64
}

func (q *Queries) ListDahuaDevices(ctx context.Context) ([]ListDahuaDevicesRow, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaDevices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDahuaDevicesRow
	for rows.Next() {
		var i ListDahuaDevicesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Ip,
			&i.Url,
			&i.Username,
			&i.Password,
			&i.Location,
			&i.Feature,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisabledAt,
			&i.Seed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaDevicesByIDs = `-- name: ListDahuaDevicesByIDs :many
SELECT
  dahua_devices.id, dahua_devices.name, dahua_devices.ip, dahua_devices.url, dahua_devices.username, dahua_devices.password, dahua_devices.location, dahua_devices.feature, dahua_devices.created_at, dahua_devices.updated_at, dahua_devices.disabled_at,
  coalesce(seed, id)
FROM
  dahua_devices
  LEFT JOIN dahua_seeds ON dahua_seeds.device_id = dahua_devices.id
WHERE
  id IN (/*SLICE:ids*/?)
`

type ListDahuaDevicesByIDsRow struct {
	ID         int64
	Name       string
	Ip         string
	Url        types.URL
	Username   string
	Password   string
	Location   types.Location
	Feature    models.DahuaFeature
	CreatedAt  types.Time
	UpdatedAt  types.Time
	DisabledAt types.NullTime
	Seed       int64
}

func (q *Queries) ListDahuaDevicesByIDs(ctx context.Context, ids []int64) ([]ListDahuaDevicesByIDsRow, error) {
	query := listDahuaDevicesByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDahuaDevicesByIDsRow
	for rows.Next() {
		var i ListDahuaDevicesByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Ip,
			&i.Url,
			&i.Username,
			&i.Password,
			&i.Location,
			&i.Feature,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisabledAt,
			&i.Seed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaDevicesForUser = `-- name: ListDahuaDevicesForUser :many
SELECT
  d.id, d.name, d.ip, d.url, d.username, d.password, d.location, d.feature, d.created_at, d.updated_at, d.disabled_at,
  coalesce(s.seed, d.id) AS seed,
  coalesce(p.level, 2)
FROM
  dahua_devices as d
  LEFT JOIN dahua_seeds AS s ON s.device_id = d.id
  LEFT JOIN dahua_permissions AS p ON p.device_id = d.id
WHERE
  true = ?1
  OR p.user_id = ?2
  OR p.group_id IN (
    SELECT
      group_id
    FROM
      group_users
    WHERE
      user_id = ?2
  )
GROUP BY
  d.id
ORDER BY
  p.level DESC
`

type ListDahuaDevicesForUserParams struct {
	Admin  interface{}
	UserID sql.NullInt64
}

type ListDahuaDevicesForUserRow struct {
	ID         int64
	Name       string
	Ip         string
	Url        types.URL
	Username   string
	Password   string
	Location   types.Location
	Feature    models.DahuaFeature
	CreatedAt  types.Time
	UpdatedAt  types.Time
	DisabledAt types.NullTime
	Seed       int64
	Level      models.DahuaPermissionLevel
}

func (q *Queries) ListDahuaDevicesForUser(ctx context.Context, arg ListDahuaDevicesForUserParams) ([]ListDahuaDevicesForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaDevicesForUser, arg.Admin, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDahuaDevicesForUserRow
	for rows.Next() {
		var i ListDahuaDevicesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Ip,
			&i.Url,
			&i.Username,
			&i.Password,
			&i.Location,
			&i.Feature,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisabledAt,
			&i.Seed,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaEventActions = `-- name: ListDahuaEventActions :many
SELECT DISTINCT
  action
FROM
  dahua_events
`

func (q *Queries) ListDahuaEventActions(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaEventActions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var action string
		if err := rows.Scan(&action); err != nil {
			return nil, err
		}
		items = append(items, action)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaEventCodes = `-- name: ListDahuaEventCodes :many
SELECT DISTINCT
  code
FROM
  dahua_events
`

func (q *Queries) ListDahuaEventCodes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaEventCodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var code string
		if err := rows.Scan(&code); err != nil {
			return nil, err
		}
		items = append(items, code)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaEventRules = `-- name: ListDahuaEventRules :many
SELECT
  id, code, ignore_db, ignore_live, ignore_mqtt
FROM
  dahua_event_rules
`

func (q *Queries) ListDahuaEventRules(ctx context.Context) ([]DahuaEventRule, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaEventRules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DahuaEventRule
	for rows.Next() {
		var i DahuaEventRule
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.IgnoreDb,
			&i.IgnoreLive,
			&i.IgnoreMqtt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaEventWorkerState = `-- name: ListDahuaEventWorkerState :many
SELECT
  id, device_id, state, error, created_at,
  max(created_at)
FROM
  dahua_event_worker_states
GROUP BY
  device_id
`

type ListDahuaEventWorkerStateRow struct {
	ID        int64
	DeviceID  int64
	State     models.DahuaEventWorkerState
	Error     sql.NullString
	CreatedAt types.Time
	Max       interface{}
}

func (q *Queries) ListDahuaEventWorkerState(ctx context.Context) ([]ListDahuaEventWorkerStateRow, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaEventWorkerState)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDahuaEventWorkerStateRow
	for rows.Next() {
		var i ListDahuaEventWorkerStateRow
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.State,
			&i.Error,
			&i.CreatedAt,
			&i.Max,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaFileCursors = `-- name: ListDahuaFileCursors :many
SELECT
  c.device_id, c.quick_cursor, c.full_cursor, c.full_epoch, c.full_complete, c.scan, c.scan_percent, c.scan_type,
  count(f.device_id) AS files
FROM
  dahua_file_cursors AS c
  LEFT JOIN dahua_files AS f ON f.device_id = c.device_id
GROUP BY
  c.device_id
`

type ListDahuaFileCursorsRow struct {
	DeviceID     int64
	QuickCursor  types.Time
	FullCursor   types.Time
	FullEpoch    types.Time
	FullComplete bool
	Scan         bool
	ScanPercent  float64
	ScanType     models.DahuaScanType
	Files        int64
}

func (q *Queries) ListDahuaFileCursors(ctx context.Context) ([]ListDahuaFileCursorsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaFileCursors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDahuaFileCursorsRow
	for rows.Next() {
		var i ListDahuaFileCursorsRow
		if err := rows.Scan(
			&i.DeviceID,
			&i.QuickCursor,
			&i.FullCursor,
			&i.FullEpoch,
			&i.FullComplete,
			&i.Scan,
			&i.ScanPercent,
			&i.ScanType,
			&i.Files,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaFileTypes = `-- name: ListDahuaFileTypes :many
SELECT DISTINCT
  type
FROM
  dahua_files
`

func (q *Queries) ListDahuaFileTypes(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaFileTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var type_ string
		if err := rows.Scan(&type_); err != nil {
			return nil, err
		}
		items = append(items, type_)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaStorageDestinations = `-- name: ListDahuaStorageDestinations :many
SELECT
  id, name, storage, server_address, port, username, password, remote_directory
FROM
  dahua_storage_destinations
`

func (q *Queries) ListDahuaStorageDestinations(ctx context.Context) ([]DahuaStorageDestination, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaStorageDestinations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DahuaStorageDestination
	for rows.Next() {
		var i DahuaStorageDestination
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Storage,
			&i.ServerAddress,
			&i.Port,
			&i.Username,
			&i.Password,
			&i.RemoteDirectory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaStreams = `-- name: ListDahuaStreams :many
SELECT
  id, internal, device_id, channel, subtype, name, mediamtx_path
FROM
  dahua_streams
ORDER BY
  device_id
`

func (q *Queries) ListDahuaStreams(ctx context.Context) ([]DahuaStream, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaStreams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DahuaStream
	for rows.Next() {
		var i DahuaStream
		if err := rows.Scan(
			&i.ID,
			&i.Internal,
			&i.DeviceID,
			&i.Channel,
			&i.Subtype,
			&i.Name,
			&i.MediamtxPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaStreamsByDevice = `-- name: ListDahuaStreamsByDevice :many
SELECT
  id, internal, device_id, channel, subtype, name, mediamtx_path
FROM
  dahua_streams
WHERE
  device_id = ?
`

func (q *Queries) ListDahuaStreamsByDevice(ctx context.Context, deviceID int64) ([]DahuaStream, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaStreamsByDevice, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DahuaStream
	for rows.Next() {
		var i DahuaStream
		if err := rows.Scan(
			&i.ID,
			&i.Internal,
			&i.DeviceID,
			&i.Channel,
			&i.Subtype,
			&i.Name,
			&i.MediamtxPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupsForUser = `-- name: ListGroupsForUser :many
SELECT
  g.id, g.name, g.description, g.created_at, g.updated_at, g.disabled_at,
  gu.created_at AS joined_at
FROM
  groups AS g
  LEFT JOIN group_users AS gu ON gu.group_id = g.id
WHERE
  gu.user_id = ?
`

type ListGroupsForUserRow struct {
	ID          int64
	Name        string
	Description string
	CreatedAt   types.Time
	UpdatedAt   types.Time
	DisabledAt  types.NullTime
	JoinedAt    sql.NullTime
}

func (q *Queries) ListGroupsForUser(ctx context.Context, userID int64) ([]ListGroupsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listGroupsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGroupsForUserRow
	for rows.Next() {
		var i ListGroupsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisabledAt,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSessionsForUserAndNotExpired = `-- name: ListUserSessionsForUserAndNotExpired :many
SELECT
  id, user_id, session, user_agent, ip, last_ip, last_used_at, created_at, expired_at
FROM
  user_sessions
WHERE
  user_id = ?
  AND expired_at > ?2
`

type ListUserSessionsForUserAndNotExpiredParams struct {
	UserID int64
	Now    types.Time
}

func (q *Queries) ListUserSessionsForUserAndNotExpired(ctx context.Context, arg ListUserSessionsForUserAndNotExpiredParams) ([]UserSession, error) {
	rows, err := q.db.QueryContext(ctx, listUserSessionsForUserAndNotExpired, arg.UserID, arg.Now)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Session,
			&i.UserAgent,
			&i.Ip,
			&i.LastIp,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.ExpiredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const normalizeDahuaFileCursor = `-- name: NormalizeDahuaFileCursor :exec
INSERT OR IGNORE INTO
  dahua_file_cursors (
    device_id,
    quick_cursor,
    full_cursor,
    full_epoch,
    scan,
    scan_percent,
    scan_type
  )
SELECT
  id,
  ?,
  ?,
  ?,
  ?,
  ?,
  ?
FROM
  dahua_devices
`

type NormalizeDahuaFileCursorParams struct {
	QuickCursor types.Time
	FullCursor  types.Time
	FullEpoch   types.Time
	Scan        bool
	ScanPercent float64
	ScanType    models.DahuaScanType
}

func (q *Queries) NormalizeDahuaFileCursor(ctx context.Context, arg NormalizeDahuaFileCursorParams) error {
	_, err := q.db.ExecContext(ctx, normalizeDahuaFileCursor,
		arg.QuickCursor,
		arg.FullCursor,
		arg.FullEpoch,
		arg.Scan,
		arg.ScanPercent,
		arg.ScanType,
	)
	return err
}

const orphanDeleteDahuaThumbnail = `-- name: OrphanDeleteDahuaThumbnail :exec
DELETE FROM dahua_thumbnails
WHERE
  id IN (
    SELECT
      thumbnail_id
    FROM
      dahua_afero_files
    WHERE
      ready = false
      AND created_at < ?
  )
`

func (q *Queries) OrphanDeleteDahuaThumbnail(ctx context.Context, createdAt types.Time) error {
	_, err := q.db.ExecContext(ctx, orphanDeleteDahuaThumbnail, createdAt)
	return err
}

const orphanListDahuaAferoFiles = `-- name: OrphanListDahuaAferoFiles :many
SELECT
  id, file_id, thumbnail_id, email_attachment_id, name, ready, size, created_at
FROM
  dahua_afero_files
WHERE
  file_id IS NULL
  AND thumbnail_id IS NULL
  AND email_attachment_id IS NULL
  AND ready = true
LIMIT
  ?
`

func (q *Queries) OrphanListDahuaAferoFiles(ctx context.Context, limit int64) ([]DahuaAferoFile, error) {
	rows, err := q.db.QueryContext(ctx, orphanListDahuaAferoFiles, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DahuaAferoFile
	for rows.Next() {
		var i DahuaAferoFile
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.ThumbnailID,
			&i.EmailAttachmentID,
			&i.Name,
			&i.Ready,
			&i.Size,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readyDahuaAferoFile = `-- name: ReadyDahuaAferoFile :one
UPDATE dahua_afero_files
SET
  ready = true,
  size = ?,
  created_at = ?
WHERE
  id = ? RETURNING id
`

type ReadyDahuaAferoFileParams struct {
	Size      int64
	CreatedAt types.Time
	ID        int64
}

func (q *Queries) ReadyDahuaAferoFile(ctx context.Context, arg ReadyDahuaAferoFileParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, readyDahuaAferoFile, arg.Size, arg.CreatedAt, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateDahuaDevice = `-- name: UpdateDahuaDevice :one
UPDATE dahua_devices
SET
  name = ?,
  url = ?,
  ip = ?,
  username = ?,
  password = ?,
  location = ?,
  feature = ?,
  updated_at = ?
WHERE
  id = ? RETURNING id
`

type UpdateDahuaDeviceParams struct {
	Name      string
	Url       types.URL
	Ip        string
	Username  string
	Password  string
	Location  types.Location
	Feature   models.DahuaFeature
	UpdatedAt types.Time
	ID        int64
}

func (q *Queries) UpdateDahuaDevice(ctx context.Context, arg UpdateDahuaDeviceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateDahuaDevice,
		arg.Name,
		arg.Url,
		arg.Ip,
		arg.Username,
		arg.Password,
		arg.Location,
		arg.Feature,
		arg.UpdatedAt,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateDahuaEventRule = `-- name: UpdateDahuaEventRule :exec
UPDATE dahua_event_rules
SET
  code = ?,
  ignore_db = ?,
  ignore_live = ?,
  ignore_mqtt = ?
WHERE
  id = ?
`

type UpdateDahuaEventRuleParams struct {
	Code       string
	IgnoreDb   bool
	IgnoreLive bool
	IgnoreMqtt bool
	ID         int64
}

func (q *Queries) UpdateDahuaEventRule(ctx context.Context, arg UpdateDahuaEventRuleParams) error {
	_, err := q.db.ExecContext(ctx, updateDahuaEventRule,
		arg.Code,
		arg.IgnoreDb,
		arg.IgnoreLive,
		arg.IgnoreMqtt,
		arg.ID,
	)
	return err
}

const updateDahuaFile = `-- name: UpdateDahuaFile :one
UPDATE dahua_files
SET
  channel = ?,
  start_time = ?,
  end_time = ?,
  length = ?,
  type = ?,
  duration = ?,
  disk = ?,
  video_stream = ?,
  flags = ?,
  events = ?,
  cluster = ?,
  partition = ?,
  pic_index = ?,
  repeat = ?,
  work_dir = ?,
  work_dir_sn = ?,
  updated_at = ?,
  storage = ?
WHERE
  device_id = ?
  AND file_path = ? RETURNING id
`

type UpdateDahuaFileParams struct {
	Channel     int64
	StartTime   types.Time
	EndTime     types.Time
	Length      int64
	Type        string
	Duration    int64
	Disk        int64
	VideoStream string
	Flags       types.StringSlice
	Events      types.StringSlice
	Cluster     int64
	Partition   int64
	PicIndex    int64
	Repeat      int64
	WorkDir     string
	WorkDirSn   bool
	UpdatedAt   types.Time
	Storage     models.Storage
	DeviceID    int64
	FilePath    string
}

func (q *Queries) UpdateDahuaFile(ctx context.Context, arg UpdateDahuaFileParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateDahuaFile,
		arg.Channel,
		arg.StartTime,
		arg.EndTime,
		arg.Length,
		arg.Type,
		arg.Duration,
		arg.Disk,
		arg.VideoStream,
		arg.Flags,
		arg.Events,
		arg.Cluster,
		arg.Partition,
		arg.PicIndex,
		arg.Repeat,
		arg.WorkDir,
		arg.WorkDirSn,
		arg.UpdatedAt,
		arg.Storage,
		arg.DeviceID,
		arg.FilePath,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateDahuaFileCursor = `-- name: UpdateDahuaFileCursor :one
UPDATE dahua_file_cursors
SET
  quick_cursor = ?,
  full_cursor = ?,
  full_epoch = ?,
  scan = ?,
  scan_percent = ?,
  scan_type = ?
WHERE
  device_id = ? RETURNING device_id, quick_cursor, full_cursor, full_epoch, full_complete, scan, scan_percent, scan_type
`

type UpdateDahuaFileCursorParams struct {
	QuickCursor types.Time
	FullCursor  types.Time
	FullEpoch   types.Time
	Scan        bool
	ScanPercent float64
	ScanType    models.DahuaScanType
	DeviceID    int64
}

func (q *Queries) UpdateDahuaFileCursor(ctx context.Context, arg UpdateDahuaFileCursorParams) (DahuaFileCursor, error) {
	row := q.db.QueryRowContext(ctx, updateDahuaFileCursor,
		arg.QuickCursor,
		arg.FullCursor,
		arg.FullEpoch,
		arg.Scan,
		arg.ScanPercent,
		arg.ScanType,
		arg.DeviceID,
	)
	var i DahuaFileCursor
	err := row.Scan(
		&i.DeviceID,
		&i.QuickCursor,
		&i.FullCursor,
		&i.FullEpoch,
		&i.FullComplete,
		&i.Scan,
		&i.ScanPercent,
		&i.ScanType,
	)
	return i, err
}

const updateDahuaFileCursorScanPercent = `-- name: UpdateDahuaFileCursorScanPercent :one
UPDATE dahua_file_cursors
SET
  scan_percent = ?
WHERE
  device_id = ? RETURNING device_id, quick_cursor, full_cursor, full_epoch, full_complete, scan, scan_percent, scan_type
`

type UpdateDahuaFileCursorScanPercentParams struct {
	ScanPercent float64
	DeviceID    int64
}

func (q *Queries) UpdateDahuaFileCursorScanPercent(ctx context.Context, arg UpdateDahuaFileCursorScanPercentParams) (DahuaFileCursor, error) {
	row := q.db.QueryRowContext(ctx, updateDahuaFileCursorScanPercent, arg.ScanPercent, arg.DeviceID)
	var i DahuaFileCursor
	err := row.Scan(
		&i.DeviceID,
		&i.QuickCursor,
		&i.FullCursor,
		&i.FullEpoch,
		&i.FullComplete,
		&i.Scan,
		&i.ScanPercent,
		&i.ScanType,
	)
	return i, err
}

const updateDahuaStorageDestination = `-- name: UpdateDahuaStorageDestination :one
UPDATE dahua_storage_destinations
SET
  name = ?,
  storage = ?,
  server_address = ?,
  port = ?,
  username = ?,
  password = ?,
  remote_directory = ?
WHERE
  id = ? RETURNING id, name, storage, server_address, port, username, password, remote_directory
`

type UpdateDahuaStorageDestinationParams struct {
	Name            string
	Storage         models.Storage
	ServerAddress   string
	Port            int64
	Username        string
	Password        string
	RemoteDirectory string
	ID              int64
}

func (q *Queries) UpdateDahuaStorageDestination(ctx context.Context, arg UpdateDahuaStorageDestinationParams) (DahuaStorageDestination, error) {
	row := q.db.QueryRowContext(ctx, updateDahuaStorageDestination,
		arg.Name,
		arg.Storage,
		arg.ServerAddress,
		arg.Port,
		arg.Username,
		arg.Password,
		arg.RemoteDirectory,
		arg.ID,
	)
	var i DahuaStorageDestination
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Storage,
		&i.ServerAddress,
		&i.Port,
		&i.Username,
		&i.Password,
		&i.RemoteDirectory,
	)
	return i, err
}

const updateDahuaStream = `-- name: UpdateDahuaStream :one
UPDATE dahua_streams
SET
  name = ?,
  mediamtx_path = ?
WHERE
  id = ? RETURNING id, internal, device_id, channel, subtype, name, mediamtx_path
`

type UpdateDahuaStreamParams struct {
	Name         string
	MediamtxPath string
	ID           int64
}

func (q *Queries) UpdateDahuaStream(ctx context.Context, arg UpdateDahuaStreamParams) (DahuaStream, error) {
	row := q.db.QueryRowContext(ctx, updateDahuaStream, arg.Name, arg.MediamtxPath, arg.ID)
	var i DahuaStream
	err := row.Scan(
		&i.ID,
		&i.Internal,
		&i.DeviceID,
		&i.Channel,
		&i.Subtype,
		&i.Name,
		&i.MediamtxPath,
	)
	return i, err
}

const updateGroup = `-- name: UpdateGroup :one
UPDATE groups
SET
  name = ?,
  description = ?,
  updated_at = ?
WHERE
  id = ? RETURNING id
`

type UpdateGroupParams struct {
	Name        string
	Description string
	UpdatedAt   types.Time
	ID          int64
}

func (q *Queries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateGroup,
		arg.Name,
		arg.Description,
		arg.UpdatedAt,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateGroupDisabledAt = `-- name: UpdateGroupDisabledAt :one
UPDATE groups
SET
  disabled_at = ?
WHERE
  id = ? RETURNING id
`

type UpdateGroupDisabledAtParams struct {
	DisabledAt types.NullTime
	ID         int64
}

func (q *Queries) UpdateGroupDisabledAt(ctx context.Context, arg UpdateGroupDisabledAtParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateGroupDisabledAt, arg.DisabledAt, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateSettings = `-- name: UpdateSettings :one
UPDATE settings
SET
  location = coalesce(?1, location),
  site_name = coalesce(?2, site_name)
WHERE
  1 = 1 RETURNING setup, site_name, location, coordinates
`

type UpdateSettingsParams struct {
	Location sql.NullString
	SiteName sql.NullString
}

func (q *Queries) UpdateSettings(ctx context.Context, arg UpdateSettingsParams) (Setting, error) {
	row := q.db.QueryRowContext(ctx, updateSettings, arg.Location, arg.SiteName)
	var i Setting
	err := row.Scan(
		&i.Setup,
		&i.SiteName,
		&i.Location,
		&i.Coordinates,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
  email = ?,
  username = ?,
  password = ?,
  updated_at = ?
WHERE
  id = ? RETURNING id
`

type UpdateUserParams struct {
	Email     string
	Username  string
	Password  string
	UpdatedAt types.Time
	ID        int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.UpdatedAt,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateUserDisabledAt = `-- name: UpdateUserDisabledAt :one
UPDATE users
SET
  disabled_at = ?
WHERE
  id = ? RETURNING id
`

type UpdateUserDisabledAtParams struct {
	DisabledAt types.NullTime
	ID         int64
}

func (q *Queries) UpdateUserDisabledAt(ctx context.Context, arg UpdateUserDisabledAtParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateUserDisabledAt, arg.DisabledAt, arg.ID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateUserSession = `-- name: UpdateUserSession :exec
UPDATE user_sessions
SET
  last_ip = ?,
  last_used_at = ?
WHERE
  session = ?
`

type UpdateUserSessionParams struct {
	LastIp     string
	LastUsedAt types.Time
	Session    string
}

func (q *Queries) UpdateUserSession(ctx context.Context, arg UpdateUserSessionParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSession, arg.LastIp, arg.LastUsedAt, arg.Session)
	return err
}

const allocateDahuaSeed = `-- name: allocateDahuaSeed :exec
UPDATE dahua_seeds
SET
  device_id = ?1
WHERE
  seed = (
    SELECT
      seed
    FROM
      dahua_seeds
    WHERE
      device_id = ?1
      OR device_id IS NULL
    ORDER BY
      device_id ASC
    LIMIT
      1
  )
`

func (q *Queries) allocateDahuaSeed(ctx context.Context, deviceID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, allocateDahuaSeed, deviceID)
	return err
}

const createDahuaDevice = `-- name: createDahuaDevice :one
INSERT INTO
  dahua_devices (
    name,
    url,
    ip,
    username,
    password,
    location,
    feature,
    created_at,
    updated_at
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id
`

type createDahuaDeviceParams struct {
	Name      string
	Url       types.URL
	Ip        string
	Username  string
	Password  string
	Location  types.Location
	Feature   models.DahuaFeature
	CreatedAt types.Time
	UpdatedAt types.Time
}

func (q *Queries) createDahuaDevice(ctx context.Context, arg createDahuaDeviceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDahuaDevice,
		arg.Name,
		arg.Url,
		arg.Ip,
		arg.Username,
		arg.Password,
		arg.Location,
		arg.Feature,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDahuaEmailAttachment = `-- name: createDahuaEmailAttachment :one
INSERT INTO
  dahua_email_attachments (message_id, file_name)
VALUES
  (?, ?) RETURNING id, message_id, file_name
`

type createDahuaEmailAttachmentParams struct {
	MessageID int64
	FileName  string
}

func (q *Queries) createDahuaEmailAttachment(ctx context.Context, arg createDahuaEmailAttachmentParams) (DahuaEmailAttachment, error) {
	row := q.db.QueryRowContext(ctx, createDahuaEmailAttachment, arg.MessageID, arg.FileName)
	var i DahuaEmailAttachment
	err := row.Scan(&i.ID, &i.MessageID, &i.FileName)
	return i, err
}

const createDahuaEmailMessage = `-- name: createDahuaEmailMessage :one
INSERT INTO
  dahua_email_messages (
    device_id,
    date,
    'from',
    ` + "`" + `to` + "`" + `,
    subject,
    ` + "`" + `text` + "`" + `,
    alarm_event,
    alarm_input_channel,
    alarm_name,
    created_at
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id, device_id, date, 'from', ` + "`" + `to` + "`" + `, subject, ` + "`" + `text` + "`" + `, alarm_event, alarm_input_channel, alarm_name, created_at
`

type createDahuaEmailMessageParams struct {
	DeviceID          int64
	Date              types.Time
	From              string
	To                types.StringSlice
	Subject           string
	Text              string
	AlarmEvent        string
	AlarmInputChannel int64
	AlarmName         string
	CreatedAt         types.Time
}

func (q *Queries) createDahuaEmailMessage(ctx context.Context, arg createDahuaEmailMessageParams) (DahuaEmailMessage, error) {
	row := q.db.QueryRowContext(ctx, createDahuaEmailMessage,
		arg.DeviceID,
		arg.Date,
		arg.From,
		arg.To,
		arg.Subject,
		arg.Text,
		arg.AlarmEvent,
		arg.AlarmInputChannel,
		arg.AlarmName,
		arg.CreatedAt,
	)
	var i DahuaEmailMessage
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Date,
		&i.From,
		&i.To,
		&i.Subject,
		&i.Text,
		&i.AlarmEvent,
		&i.AlarmInputChannel,
		&i.AlarmName,
		&i.CreatedAt,
	)
	return i, err
}

const createDahuaFileCursor = `-- name: createDahuaFileCursor :exec
INSERT INTO
  dahua_file_cursors (
    device_id,
    quick_cursor,
    full_cursor,
    full_epoch,
    scan,
    scan_percent,
    scan_type
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?)
`

type createDahuaFileCursorParams struct {
	DeviceID    int64
	QuickCursor types.Time
	FullCursor  types.Time
	FullEpoch   types.Time
	Scan        bool
	ScanPercent float64
	ScanType    models.DahuaScanType
}

func (q *Queries) createDahuaFileCursor(ctx context.Context, arg createDahuaFileCursorParams) error {
	_, err := q.db.ExecContext(ctx, createDahuaFileCursor,
		arg.DeviceID,
		arg.QuickCursor,
		arg.FullCursor,
		arg.FullEpoch,
		arg.Scan,
		arg.ScanPercent,
		arg.ScanType,
	)
	return err
}

const createDahuaStreamDefault = `-- name: createDahuaStreamDefault :one
INSERT INTO
  dahua_streams (
    device_id,
    channel,
    subtype,
    name,
    mediamtx_path,
    internal
  )
VALUES
  (?, ?, ?, ?, ?, true)
ON CONFLICT DO
UPDATE
SET
  internal = true RETURNING ID
`

type createDahuaStreamDefaultParams struct {
	DeviceID     int64
	Channel      int64
	Subtype      int64
	Name         string
	MediamtxPath string
}

func (q *Queries) createDahuaStreamDefault(ctx context.Context, arg createDahuaStreamDefaultParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDahuaStreamDefault,
		arg.DeviceID,
		arg.Channel,
		arg.Subtype,
		arg.Name,
		arg.MediamtxPath,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getDahuaEventRuleByEvent = `-- name: getDahuaEventRuleByEvent :many
SELECT
  ignore_db,
  ignore_live,
  ignore_mqtt,
  code
FROM
  dahua_event_device_rules
WHERE
  device_id = ?1
  AND (
    dahua_event_device_rules.code = ?2
    OR dahua_event_device_rules.code = ''
  )
UNION ALL
SELECT
  ignore_db,
  ignore_live,
  ignore_mqtt,
  code
FROM
  dahua_event_rules
WHERE
  dahua_event_rules.code = ?2
  OR dahua_event_rules.code = ''
ORDER BY
  code DESC
`

type getDahuaEventRuleByEventParams struct {
	DeviceID int64
	Code     string
}

type getDahuaEventRuleByEventRow struct {
	IgnoreDb   bool
	IgnoreLive bool
	IgnoreMqtt bool
	Code       string
}

func (q *Queries) getDahuaEventRuleByEvent(ctx context.Context, arg getDahuaEventRuleByEventParams) ([]getDahuaEventRuleByEventRow, error) {
	rows, err := q.db.QueryContext(ctx, getDahuaEventRuleByEvent, arg.DeviceID, arg.Code)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []getDahuaEventRuleByEventRow
	for rows.Next() {
		var i getDahuaEventRuleByEventRow
		if err := rows.Scan(
			&i.IgnoreDb,
			&i.IgnoreLive,
			&i.IgnoreMqtt,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDahuaDeviceByFeature = `-- name: listDahuaDeviceByFeature :many
SELECT
  dahua_devices.id, dahua_devices.name, dahua_devices.ip, dahua_devices.url, dahua_devices.username, dahua_devices.password, dahua_devices.location, dahua_devices.feature, dahua_devices.created_at, dahua_devices.updated_at, dahua_devices.disabled_at,
  coalesce(seed, id)
FROM
  dahua_devices
  LEFT JOIN dahua_seeds ON dahua_seeds.device_id = dahua_devices.id
WHERE
  feature & ?1 = ?1
`

type listDahuaDeviceByFeatureRow struct {
	ID         int64
	Name       string
	Ip         string
	Url        types.URL
	Username   string
	Password   string
	Location   types.Location
	Feature    models.DahuaFeature
	CreatedAt  types.Time
	UpdatedAt  types.Time
	DisabledAt types.NullTime
	Seed       int64
}

func (q *Queries) listDahuaDeviceByFeature(ctx context.Context, feature models.DahuaFeature) ([]listDahuaDeviceByFeatureRow, error) {
	rows, err := q.db.QueryContext(ctx, listDahuaDeviceByFeature, feature)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []listDahuaDeviceByFeatureRow
	for rows.Next() {
		var i listDahuaDeviceByFeatureRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Ip,
			&i.Url,
			&i.Username,
			&i.Password,
			&i.Location,
			&i.Feature,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DisabledAt,
			&i.Seed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDahuaStreamDefault = `-- name: updateDahuaStreamDefault :exec
UPDATE dahua_streams
SET
  internal = false
WHERE
  device_id = ?
`

func (q *Queries) updateDahuaStreamDefault(ctx context.Context, deviceID int64) error {
	_, err := q.db.ExecContext(ctx, updateDahuaStreamDefault, deviceID)
	return err
}
